---
layout: post
title: Head First Design Patterns
---

## 设计原则
  - 找出程序中会变化的方面，然后将其和固定不变的方面相分离
  - 针对接口编程，不针对实现编程
  - 多用组合, 少用继承
  - 松耦合
  - 类应该对扩展开放，对修改关闭 (即在不修改现有代码的情况下，就可搭配新的行为)


## 策略模式
  定义了算法族， 分别封装起来， 让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户

  - 使用接口， 代理

## 观察者模式
  定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新
  
  - subject <-> observer
  - java 内置 java.util.Observerable  <->  java.util.Observer

  button listener 使用了观察者模式

## 装饰者模式
  装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的

  动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案

  装饰者和被装饰者被必须是一样的类型，有共同的超类。该模式利用继承达到“类型匹配”，而不是利用继承获得“行为”

  范例： java IO
  
  缺点：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，会造成使用此 API 的程序员的困扰

## 工厂模式
  - 工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。它让类把实例化推迟到子类
  - 抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

  need to be understand

## 单件模式
  确保一个类只有一个实例，并提供一个全局访问点

  处理多线程 bug：

  - synchronized
  - 关注性能时：在 JVM 加载此类时 静态初始化 创建单件


  范例：

    - 线程池
    - 缓存
    - 对话框
    - 注册表
    - 日志
    - 驱动程序


## 命令模式



