---
layout: post
title: Head First Design Patterns
---

## 设计原则
  - 找出程序中会变化的方面，然后将其和固定不变的方面相分离
  - 针对接口编程，不针对实现编程
  - 多用组合, 少用继承
  - 松耦合
  - 类应该对扩展开放，对修改关闭 (即在不修改现有代码的情况下，就可搭配新的行为)
  - 最少知识原则：只和你的密友谈话
  - 好莱坞原则：别调用我，我会调用你
  - 单一责任：一个类应只有一个引起变化的原因


## 策略模式
  定义了算法族， 分别封装起来， 让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户

  - 使用接口， 委托代理

## 观察者模式
  定义了对象之间的一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新
  
  - subject <-> observer
  - java 内置 java.util.Observerable  <->  java.util.Observer

  button listener 使用了观察者模式

## 装饰者模式
  装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的

  动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案

  装饰者和被装饰者被必须是一样的类型，有共同的超类。该模式利用继承达到“类型匹配”，而不是利用继承获得“行为”

  范例： java IO
  
  缺点：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，会造成使用此 API 的程序员的困扰

## 工厂模式
  - 工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。它让类把实例化推迟到子类
  - 抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

  need to be understand

## 单件模式
  确保一个类只有一个实例，并提供一个全局访问点

  处理多线程 bug：

  - synchronized
  - 关注性能时：在 JVM 加载此类时 静态初始化 创建单件


  范例：

  - 线程池
  - 缓存
  - 对话框
  - 注册表
  - 日志
  - 驱动程序


## 命令模式
  将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作


## 适配器模式
  将一个类的接口，转换成客户期望的另一个接口。适配器让原来不兼容的类可以合作无间

  范例：
    Enumeration -> Iterator

## 外观模式
  提供了一个统一的接口，用于访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

## 模版方法模式
  在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤

  对模版方法使用钩子

  范例：Array 的 sort() 方法, 要排序的对象实现 compareTo()

## 迭代器模式 
  提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示

## 组合模式
  允许你将对象组合成树形结构来表现“整体／部分”层次结构。组合能让客户以一致的方式处理个别对象和对象组合

## 状态模式
  允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类

## 代理模式
  为另一个对象提供一个替身或占位符，以访问这个对象

## 复合模式
  结合两个或以上的模式，组成一个解决方案，解决一再发生的一般性问题

  MVC:

  - model -->  controller and view: 观察者模式
  - view  --> controller: 策略模式
  - view 的不同组建：组合模式


